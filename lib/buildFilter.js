const _ = require('lodash');
const log = require('debug')('loopback:connector:elasticsearch');

function buildFilter(modelName, idName, criteria, size, offset) {
  const self = this;
  log('ESConnector.prototype.buildFilter', 'model', modelName, 'idName', idName,
    'criteria', JSON.stringify(criteria, null, 0));

  if (idName === undefined || idName === null) {
    throw new Error('idName not set!');
  }

  const filter = this.addDefaults(modelName, 'buildFilter');
  filter.body = {};

  if (size !== undefined && size !== null) {
    filter.size = size;
  }
  if (offset !== undefined && offset !== null) {
    filter.from = offset;
  }

  if (criteria) {
    // `criteria` is set by app-devs, therefore, it overrides any connector level arguments
    if (criteria.limit !== undefined && criteria.limit !== null) {
      filter.size = criteria.limit;
    }
    if (criteria.skip !== undefined && criteria.skip !== null) {
      filter.from = criteria.skip;
    } else if (criteria.offset !== undefined
        && criteria.offset !== null) { // use offset as an alias for skip
      filter.from = criteria.offset;
    }
    if (criteria.fields) {
      // { fields: {propertyName: <true|false>, propertyName: <true|false>, ... } }
      // filter.body.fields = self.buildOrder(model, idName, criteria.fields);
      // TODO: make it so
      // http://www.elastic.co/guide/en/elasticsearch/reference/1.x/search-request-source-filtering.html
      // http://www.elastic.co/guide/en/elasticsearch/reference/1.x/search-request-fields.html
      /* POST /shakespeare/User/_search
       {
       '_source': {
       'include': ['seq'],
       'exclude': ['seq']
       }
       } */

      /* @raymondfeng and @bajtos - I'm observing something super strange,
       i haven't implemented the FIELDS filter for elasticsearch connector
       but the test which should fail until I implement such a feature ... is actually passing!
       ... did someone at some point of time implement an in-memory filter for FIELDS
       in the underlying loopback-connector implementation? */

      // Elasticsearch _source filtering code
      /* if (Array.isArray(criteria.fields) || typeof criteria.fields === 'string') {
        filter.body._source = criteria.fields;
      } else if (typeof criteria.fields === 'object' && Object.keys(criteria.fields).length > 0) {
        filter.body._source.includes = _.map(_.pickBy(criteria.fields, function(v, k) {
          return v === true;
        }), function(v, k) { return k; });
        filter.body._source.excludes = _.map(_.pickBy(criteria.fields, function(v, k) {
          return v === false;
        }), function(v, k) { return k; });
      } */
    }
    if (criteria.order) {
      log('ESConnector.prototype.buildFilter', 'will delegate sorting to buildOrder()');
      filter.body.sort = self.buildOrder(modelName, idName, criteria.order);
    } else { // TODO: expensive~ish and no clear guidelines so turn it off?
      // var idNames = this.idNames(model); // TODO: support for compound ids?
      // eslint-disable-next-line no-underscore-dangle
      const modelProperties = this._models[modelName].properties;
      if (idName === 'id' && modelProperties.id.generated) {
        // filter.body.sort = ['_id']; // requires mapping to contain: ...
        // ...'_id' : {'index' : 'not_analyzed','store' : true}
        log('ESConnector.prototype.buildFilter', 'will sort on _id by default when IDs are meant to be auto-generated by elasticsearch');
        filter.body.sort = ['_id'];
      } else {
        log('ESConnector.prototype.buildFilter', 'will sort on loopback specified IDs');
        filter.body.sort = [idName]; // default sort should be based on fields marked as id
      }
    }
    if (criteria.where) {
      filter.body.query = self.buildWhere(modelName, idName, criteria.where).query;
    } else if (criteria.suggests) { // TODO: remove HACK!!!
      filter.body = {
        suggest: criteria.suggests
      }; // assume that the developer has provided ES compatible DSL
    } else if (criteria.native) {
      filter.body = criteria.native; // assume that the developer has provided ES compatible DSL
    } else if (_.keys(criteria).length === 0) {
      filter.body = {
        query: {
          bool: {
            must: {
              match_all: {}
            },
            filter: [{
              term: {
                docType: modelName
              }
            }]
          }
        }
      };
    } else if (!Object.prototype.hasOwnProperty.call(criteria, 'where')) {
      // For queries without 'where' filter, add docType filter
      filter.body.query = self.buildWhere(modelName, idName, criteria.where || {}).query;
    }
  }

  log('ESConnector.prototype.buildFilter', 'constructed', JSON.stringify(filter, null, 0));
  return filter;
}

module.exports.buildFilter = buildFilter;
